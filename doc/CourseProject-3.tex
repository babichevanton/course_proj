\chapter{Исследование и построение решения}

Для реализации решения был выбран подход, предложенный АФФТАРОМ, поскольку он создан для решения проблемы извлечения информации именно в неструктурированном тексте. Авторы подхода предлагают находить решение с помощью так называемого множества элементарных исходов. Каждый элемент этого множества представляет собой совокупность пар \{атрибут: значение\} и описывает ровно один объект из имеющейся базы знаний.

В рамках решения поставленной задачи необходимо решить следующие подзадачи:
\begin{enumerate}
	\item Поиск примерной схемы поста
	\item Извлечение информации
\end{enumerate}

Рассмотрим подробнее каждую из подзадач.


\section{Поиск примерной схемы поста}

Сперва необходимо выяснить структуру поста. Для этого пост сравнивается с элементами множества элементарных исходов (назовем его множеством кандидатов). Для каждого кандидата строится вектор признаков, который затем подается на вход классификатору, обученному относить вектор к одному из 2 классов: \textit{кандидат соответствует посту} и \textit{кандидат не соответствует посту}. Искомой схемой поста является кандидат, отнесенный к классу схем с наибольшей вероятностью.

Эта задача решается в 2 шага;
\begin{enumerate}
	\item Предобработка (построение подмножества кандидатов)
	\item Связывание (построение векторов и классификация)
\end{enumerate}

Рассмотрим подробнее каждый из шагов.


\subsection{Предобработка}

Каждый элемент вектора признаков представляет собой значение определенной меры, вычисленной для поста и конкретного атрибута кандидата либо кандидата в целом. Поскольку кандидат содержит в среднем около 20 атрибутов, а набор мер состоит из 6 мер, вычисление каждой из которых подразумевает сравнение строк, построение вектора признаков является недешевой операцией. В множестве кандидатов находится около десятка тысяч элементов, поэтому построение векторов признаков для каждого кандидата - достаточно длительная задача. Поэтому с помощью приблизительного сравнения выбирается подмножество кандидатов, для которого в дальнейшем и будет производиться классификация.

Для этого множество кандидатов кластеризуется по значениям нескольких конкретных атрибутов. В один кластер попадает группа кандидатов с одинаковыми значениями атрибутов, указанных при кластеризации. Один кластер может быть описан в виде правила, которому удовлетворяют все элементы этого кластера. Правило удобно представлять в виде конъюнкции пар \{атрибут: значение\}. Например, пусть множество кандидатов состоит из 4 элементов:

\begin{tabular}{l l l l l}
	\{имя: ”стол”\} & \{длина: 120\} & \{ширина: 80\} & \{материал: ”дерево”\} & [1]\\
	\{имя: ”стол”\} & \{длина: 120\} & \{ширина: 60\} & \{материал: ”стекло”\} & [2]\\
	\{имя: ”табурет”\} & \{длина: 70\} & \{ширина: 70\} & \{материал: ”дерево”\} & [3]\\
	\{имя: ”табурет”\} & \{длина: 60\} & \{ширина: 60\} & \{материал: ”сталь”\} & [4]\\
\end{tabular}
\linebreak
Тогда правилу \{имя: “стол”\}\{длина: 120\} соответствуют элементы 1 и 2, а правилу \{имя: “табурет”\}\{материал: “сталь”\} - 4 элемент. 

Обрабатывать и классифицировать в дальнейшем предстоит элементы одного выбранного кластера. Выбираемый кластер должен соответствовать 2 требованиям:
\begin{enumerate}
	\item Он должен состоять из как можно меньшего числа элементов (чтобы строить меньше векторов признаков)
	\item Он должен иметь достаточно элементов, чтобы содержать кандидатов, наиболее похожих на содержание поста - \textit{перспективных кандидатов}
\end{enumerate}

Для контроля требований над правилом вводятся 2 меры: 
\begin{itemize}
	\item $Reduction Ratio (RR) = 1 - \frac{C}{N}$, где $C$ --- мощность кластера, описываемого правилом, а $N$ --- мощность множества элементарных исходов
	\item $Pair Completeness (PC) = \frac{T_n}{S_n}$, где $T_n$ --- мощность множества перспективных кандидатов, содержащихся в кластере, описываемом правилом, а $S_n$ --- мощность множества перспективных кандидатов в множестве всех кандидатов.
\end{itemize}

Задача нахождения подмножества кандидатов сводится к нахождению правил, описывающих систему кластеров, содержащих всех перспективных кандидатов. Для этого используется sequentional covering algorythm, суть которого в следующем:\\

\noindent 
\textit{\textbf{перспективные кандидаты} = множество элементов, требующих покрытия\\
\textbf{система правил} = пустое множество\\
пока \textbf{перспективные кандидаты} не пусто, выполнить:\\
\-\hspace{1cm}	найти одно правило\\
\-\hspace{1cm}	убрать из \textbf{перспективные кандидаты} элементы, которые оно покрывает\\
\-\hspace{1cm}	добавить найденное правило к \textbf{система правил}\\
\textbf{результат} - \textbf{система правил}\\
} %textit

На каждом шаге ищется правило, максимизирующее $RR$ и имеющее $PC >= 0.5$. Для его поиска используется следующий алгоритм:\\

\noindent 
\textit{\textbf{атрибуты} = множество всех атрибутов\\
\textbf{кандидаты} = множество кандидатов для покрытия\\
\textbf{правило} = пустое множество\\
пока \textbf{атрибуты} не пусто, выполнить:\\
\-\hspace{1cm}	\textbf{часть правила} = \textbf{правило}\\
\-\hspace{1cm}	для каждой пары \{атрибут: значение\} из \textbf{атрибуты} выполнить:\\
\-\hspace{2cm}	добавить к \textbf{часть правила} пару \{атрибут: значение\}\\
\-\hspace{2cm}	если RR(\textbf{часть правила}) > RR(\textbf{правило}) и PC(\textbf{часть правила}) $>= 0.5$, то\\
\-\hspace{3cm}	\textbf{правило} = \textbf{часть правила}\\
\-\hspace{2cm}	удалить из \textbf{часть правила} добавленную ранее пару\\
\-\hspace{1cm}	если \textbf{правило} не изменилось, то\\
\-\hspace{2cm}	\textbf{результат} - \textbf{правило}\\
\-\hspace{1cm}	иначе\\
\-\hspace{2cm}	удалить атрибут, добавленный в \textbf{правило}, со всеми значениями из \textbf{атрибуты}\\
\textbf{результат} - \textbf{правило}\\
} %textit


\subsection{Связывание}

Для поста и каждого кандидата из подмножества, полученного в ходе предобработки, строится вектор признаков $V_{rl}$, имеющий следующую структуру:\\

\noindent
\textit{$V_{rl}(\text{пост}, \text{кандидат})$ = (\\
\-\hspace{1cm}	$RL\_scores(\text{пост}, \text{атр}_1)$\\
\-\hspace{1cm}	$RL\_scores(\text{пост}, \text{атр}_2)$\\
\-\hspace{1cm}	\ldots\\
\-\hspace{1cm}	$RL\_scores(\text{пост}, \text{атр}_1 \text{атр}_2 \ldots\text{атр}_n)$\\
} %textit

Вектор $RL\_scores(str_1, str_2)$ имеет следующую структуру:\\

\noindent
\textit{$RL\_scores(str_1, str_2)$ = (\\
\-\hspace{1cm}	$JaccardSim(str_1, str_2)$\\
\-\hspace{1cm}	$LevensteinDist(str_1, str_2)$\\
\-\hspace{1cm}	$JaroWinklerSim(str_1, str_2)$\\
\-\hspace{1cm}	$SmithWatermanSim(str_1, str_2)$\\
\-\hspace{1cm}	$Soundex(str_1, str_2)$\\
\-\hspace{1cm}	$PorterStemmer(str_1, str_2)$\\
} %textit

Для полученных векторов проводится процедура binary rescoring, которая заключается в приведении векторов действительных чисел к двоичным векторам. Правило приведения таково: компонента вектора становится 1, если ее значение максимально среди значений этой же компоненты всех остальных векторов, и 0, если иначе. Если несколько векторов обладают максимальным значением какой-либо компоненты, то у всех этих векторов компонента в процессе binary rescoring станет равной 1. Например, следующие вектора

\begin{tabular}{l l l l l l l}
	( & 0.21 & 0.0 & 0.5 & -0.2 & 3.0 & )\\
	( & 0.5 & 0.0 & 0.5 & -0.3 & 2.0 & )\\
	( & -0.12 & 0.3 & 0.3 & -0.7 & 3.0 & )\\
\end{tabular}
\linebreak
после binary rescoring выглядят так:

\begin{tabular}{l l l l l l l}
	( & 0 & 0 & 1 & 1 & 1 & )\\
	( & 1 & 0 & 1 & 0 & 0 & )\\
	( & 0 & 1 & 0 & 0 & 1 & )\\
\end{tabular}
\linebreak
Далее вектора подаются на вход классификатору SVM, обученному относить вектор к одному из 2 классов: \textit{кандидат соответствует посту} и \textit{кандидат не соответствует посту}. Среди всех кандидатов, отнесенных к классу \textit{кандидат соответствует посту} выбирается единственный, чье отнесение к данному классу сделано классификатором с большей вероятностью. Выбранный кандидат является схемой поста.


\section{Извлечение информации}

На этом шаге для найденной схемы и каждого токена поста строится вектор признаков $V_{ie}$, имеющий следующую структуру:\\

\noindent
\textit{$V_{ie}(\text{токен}, \text{схема})$ = (\\
\-\hspace{1cm}	$IE\_scores(\text{токен}, \text{атр}_1)$\\
\-\hspace{1cm}	$IE\_scores(\text{токен}, \text{атр}_2)$\\
\-\hspace{1cm}	\ldots\\
\-\hspace{1cm}	$IE\_scores(\text{токен}, \text{атр}_n)$\\
} %textit

Вектор $IE\_scores(str_1, str_2)$ имеет следующую структуру:\\

\noindent
\textit{$RL\_scores(str_1, str_2)$ = (\\
\-\hspace{1cm}	$LevensteinDist(str_1, str_2)$\\
\-\hspace{1cm}	$JaroWinklerSim(str_1, str_2)$\\
\-\hspace{1cm}	$SmithWatermanSim(str_1, str_2)$\\
\-\hspace{1cm}	$Soundex(str_1, str_2)$\\
\-\hspace{1cm}	$PorterStemmer(str_1, str_2)$\\
} %textit

Далее вектора подаются на вход классификатору Multi-Class SVM, обученному каждому токену поста ставить в соответствие метку того атрибута, к которому наиболее вероятно токен принадлежит. После этого для группы токенов, отнесенных к одному и тому же атрибуту, проводится процедура чистки, а именно изменения метки токена, который на самом деле не являются значением выбранного атрибута, на ``пустышку''. ``Пустышками'' в посте являются токены, которые не принадлежат значениям ни одного из атрибутов. Например, в объявлении о продаже товара это могут быть токены ``cheap'', ``for sale'', ``used'' и т. д. Суть чистки следующая:\\

\begin{enumerate}
	\item Из группы токенов формируется значение атрибута в посте (например, строка``tok1 tok2 … tokn'')
	\item Для полученной строки и значения соотнесенного атрибута из схемы поста вычисляется 2 меры: JaccardSim и JaroWinklerSim. Полученные значения считаются базовыми
	\item Затем по очереди из строки убирается по одному токену, и для полученной строки и значения атрибута заново вычисляются меры
	\item Если значения обоих мер возросли по сравнению с базовыми, то полученные значения сами становятся базовыми, а убранный токен становится кандидатом на удаление (замещая предыдущего кандидата, если он был)
	\item После проверки всех токенов кандидату на удаление ставится метка ``пустышка''
	\item Процесс повторяется, пока в при проверке токенов удается найти хотя бы одного кандидата на удаление
	\item Когда кандидатов на удаление больше нет, проверяются текущие значения мер. Если они меньше необходимых минимумов (для каждой меры свой), то всем токенам атрибута ставится метка ``пустышка''
\end{enumerate}

После очистки атрибутов остается пост, каждый токен которого помечен меткой-атрибутом либо меткой-``пустышкой'' - требуемый в задаче результат.
